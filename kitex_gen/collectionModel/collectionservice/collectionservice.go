// Code generated by Kitex v0.3.1. DO NOT EDIT.

package collectionservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"google.golang.org/protobuf/proto"
	"searchengine3090ti/kitex_gen/collectionModel"
)

func serviceInfo() *kitex.ServiceInfo {
	return collectionServiceServiceInfo
}

var collectionServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "CollectionService"
	handlerType := (*collectionModel.CollectionService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateCollection": kitex.NewMethodInfo(createCollectionHandler, newCreateCollectionArgs, newCreateCollectionResult, false),
		"GetCollection":    kitex.NewMethodInfo(getCollectionHandler, newGetCollectionArgs, newGetCollectionResult, false),
		"MGetCollection":   kitex.NewMethodInfo(mGetCollectionHandler, newMGetCollectionArgs, newMGetCollectionResult, false),
		"DeleteCollection": kitex.NewMethodInfo(deleteCollectionHandler, newDeleteCollectionArgs, newDeleteCollectionResult, false),
		"AddEntry":         kitex.NewMethodInfo(addEntryHandler, newAddEntryArgs, newAddEntryResult, false),
		"DeleteEntry":      kitex.NewMethodInfo(deleteEntryHandler, newDeleteEntryArgs, newDeleteEntryResult, false),
		"SetName":          kitex.NewMethodInfo(setNameHandler, newSetNameArgs, newSetNameResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "collection",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createCollectionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.CreateColltRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).CreateCollection(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateCollectionArgs:
		success, err := handler.(collectionModel.CollectionService).CreateCollection(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateCollectionResult)
		realResult.Success = success
	}
	return nil
}
func newCreateCollectionArgs() interface{} {
	return &CreateCollectionArgs{}
}

func newCreateCollectionResult() interface{} {
	return &CreateCollectionResult{}
}

type CreateCollectionArgs struct {
	Req *collectionModel.CreateColltRequest
}

func (p *CreateCollectionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateCollectionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateCollectionArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.CreateColltRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateCollectionArgs_Req_DEFAULT *collectionModel.CreateColltRequest

func (p *CreateCollectionArgs) GetReq() *collectionModel.CreateColltRequest {
	if !p.IsSetReq() {
		return CreateCollectionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateCollectionArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateCollectionResult struct {
	Success *collectionModel.CreateColltResponse
}

var CreateCollectionResult_Success_DEFAULT *collectionModel.CreateColltResponse

func (p *CreateCollectionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateCollectionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateCollectionResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.CreateColltResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateCollectionResult) GetSuccess() *collectionModel.CreateColltResponse {
	if !p.IsSetSuccess() {
		return CreateCollectionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateCollectionResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.CreateColltResponse)
}

func (p *CreateCollectionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getCollectionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.GetColltRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).GetCollection(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetCollectionArgs:
		success, err := handler.(collectionModel.CollectionService).GetCollection(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetCollectionResult)
		realResult.Success = success
	}
	return nil
}
func newGetCollectionArgs() interface{} {
	return &GetCollectionArgs{}
}

func newGetCollectionResult() interface{} {
	return &GetCollectionResult{}
}

type GetCollectionArgs struct {
	Req *collectionModel.GetColltRequest
}

func (p *GetCollectionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetCollectionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetCollectionArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.GetColltRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetCollectionArgs_Req_DEFAULT *collectionModel.GetColltRequest

func (p *GetCollectionArgs) GetReq() *collectionModel.GetColltRequest {
	if !p.IsSetReq() {
		return GetCollectionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetCollectionArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetCollectionResult struct {
	Success *collectionModel.GetColltResponse
}

var GetCollectionResult_Success_DEFAULT *collectionModel.GetColltResponse

func (p *GetCollectionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetCollectionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetCollectionResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.GetColltResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetCollectionResult) GetSuccess() *collectionModel.GetColltResponse {
	if !p.IsSetSuccess() {
		return GetCollectionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetCollectionResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.GetColltResponse)
}

func (p *GetCollectionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mGetCollectionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.MGetColltResquest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).MGetCollection(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MGetCollectionArgs:
		success, err := handler.(collectionModel.CollectionService).MGetCollection(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MGetCollectionResult)
		realResult.Success = success
	}
	return nil
}
func newMGetCollectionArgs() interface{} {
	return &MGetCollectionArgs{}
}

func newMGetCollectionResult() interface{} {
	return &MGetCollectionResult{}
}

type MGetCollectionArgs struct {
	Req *collectionModel.MGetColltResquest
}

func (p *MGetCollectionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MGetCollectionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MGetCollectionArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.MGetColltResquest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MGetCollectionArgs_Req_DEFAULT *collectionModel.MGetColltResquest

func (p *MGetCollectionArgs) GetReq() *collectionModel.MGetColltResquest {
	if !p.IsSetReq() {
		return MGetCollectionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MGetCollectionArgs) IsSetReq() bool {
	return p.Req != nil
}

type MGetCollectionResult struct {
	Success *collectionModel.MGetColltResponse
}

var MGetCollectionResult_Success_DEFAULT *collectionModel.MGetColltResponse

func (p *MGetCollectionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MGetCollectionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MGetCollectionResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.MGetColltResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MGetCollectionResult) GetSuccess() *collectionModel.MGetColltResponse {
	if !p.IsSetSuccess() {
		return MGetCollectionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MGetCollectionResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.MGetColltResponse)
}

func (p *MGetCollectionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteCollectionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.DeleteColltRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).DeleteCollection(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteCollectionArgs:
		success, err := handler.(collectionModel.CollectionService).DeleteCollection(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteCollectionResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteCollectionArgs() interface{} {
	return &DeleteCollectionArgs{}
}

func newDeleteCollectionResult() interface{} {
	return &DeleteCollectionResult{}
}

type DeleteCollectionArgs struct {
	Req *collectionModel.DeleteColltRequest
}

func (p *DeleteCollectionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteCollectionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteCollectionArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.DeleteColltRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteCollectionArgs_Req_DEFAULT *collectionModel.DeleteColltRequest

func (p *DeleteCollectionArgs) GetReq() *collectionModel.DeleteColltRequest {
	if !p.IsSetReq() {
		return DeleteCollectionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteCollectionArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteCollectionResult struct {
	Success *collectionModel.DeleteColltResponse
}

var DeleteCollectionResult_Success_DEFAULT *collectionModel.DeleteColltResponse

func (p *DeleteCollectionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteCollectionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteCollectionResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.DeleteColltResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteCollectionResult) GetSuccess() *collectionModel.DeleteColltResponse {
	if !p.IsSetSuccess() {
		return DeleteCollectionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteCollectionResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.DeleteColltResponse)
}

func (p *DeleteCollectionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func addEntryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.AddEntryRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).AddEntry(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddEntryArgs:
		success, err := handler.(collectionModel.CollectionService).AddEntry(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddEntryResult)
		realResult.Success = success
	}
	return nil
}
func newAddEntryArgs() interface{} {
	return &AddEntryArgs{}
}

func newAddEntryResult() interface{} {
	return &AddEntryResult{}
}

type AddEntryArgs struct {
	Req *collectionModel.AddEntryRequest
}

func (p *AddEntryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AddEntryArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AddEntryArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.AddEntryRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddEntryArgs_Req_DEFAULT *collectionModel.AddEntryRequest

func (p *AddEntryArgs) GetReq() *collectionModel.AddEntryRequest {
	if !p.IsSetReq() {
		return AddEntryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddEntryArgs) IsSetReq() bool {
	return p.Req != nil
}

type AddEntryResult struct {
	Success *collectionModel.AddEntryResponse
}

var AddEntryResult_Success_DEFAULT *collectionModel.AddEntryResponse

func (p *AddEntryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AddEntryResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AddEntryResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.AddEntryResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddEntryResult) GetSuccess() *collectionModel.AddEntryResponse {
	if !p.IsSetSuccess() {
		return AddEntryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddEntryResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.AddEntryResponse)
}

func (p *AddEntryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteEntryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.DeleteEntryRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).DeleteEntry(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteEntryArgs:
		success, err := handler.(collectionModel.CollectionService).DeleteEntry(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteEntryResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteEntryArgs() interface{} {
	return &DeleteEntryArgs{}
}

func newDeleteEntryResult() interface{} {
	return &DeleteEntryResult{}
}

type DeleteEntryArgs struct {
	Req *collectionModel.DeleteEntryRequest
}

func (p *DeleteEntryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteEntryArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteEntryArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.DeleteEntryRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteEntryArgs_Req_DEFAULT *collectionModel.DeleteEntryRequest

func (p *DeleteEntryArgs) GetReq() *collectionModel.DeleteEntryRequest {
	if !p.IsSetReq() {
		return DeleteEntryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteEntryArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteEntryResult struct {
	Success *collectionModel.DeleteEntryResponse
}

var DeleteEntryResult_Success_DEFAULT *collectionModel.DeleteEntryResponse

func (p *DeleteEntryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteEntryResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteEntryResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.DeleteEntryResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteEntryResult) GetSuccess() *collectionModel.DeleteEntryResponse {
	if !p.IsSetSuccess() {
		return DeleteEntryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteEntryResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.DeleteEntryResponse)
}

func (p *DeleteEntryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func setNameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(collectionModel.SetNameRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(collectionModel.CollectionService).SetName(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SetNameArgs:
		success, err := handler.(collectionModel.CollectionService).SetName(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SetNameResult)
		realResult.Success = success
	}
	return nil
}
func newSetNameArgs() interface{} {
	return &SetNameArgs{}
}

func newSetNameResult() interface{} {
	return &SetNameResult{}
}

type SetNameArgs struct {
	Req *collectionModel.SetNameRequest
}

func (p *SetNameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SetNameArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SetNameArgs) Unmarshal(in []byte) error {
	msg := new(collectionModel.SetNameRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SetNameArgs_Req_DEFAULT *collectionModel.SetNameRequest

func (p *SetNameArgs) GetReq() *collectionModel.SetNameRequest {
	if !p.IsSetReq() {
		return SetNameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SetNameArgs) IsSetReq() bool {
	return p.Req != nil
}

type SetNameResult struct {
	Success *collectionModel.SetNameResponse
}

var SetNameResult_Success_DEFAULT *collectionModel.SetNameResponse

func (p *SetNameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SetNameResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SetNameResult) Unmarshal(in []byte) error {
	msg := new(collectionModel.SetNameResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SetNameResult) GetSuccess() *collectionModel.SetNameResponse {
	if !p.IsSetSuccess() {
		return SetNameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SetNameResult) SetSuccess(x interface{}) {
	p.Success = x.(*collectionModel.SetNameResponse)
}

func (p *SetNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateCollection(ctx context.Context, Req *collectionModel.CreateColltRequest) (r *collectionModel.CreateColltResponse, err error) {
	var _args CreateCollectionArgs
	_args.Req = Req
	var _result CreateCollectionResult
	if err = p.c.Call(ctx, "CreateCollection", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetCollection(ctx context.Context, Req *collectionModel.GetColltRequest) (r *collectionModel.GetColltResponse, err error) {
	var _args GetCollectionArgs
	_args.Req = Req
	var _result GetCollectionResult
	if err = p.c.Call(ctx, "GetCollection", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MGetCollection(ctx context.Context, Req *collectionModel.MGetColltResquest) (r *collectionModel.MGetColltResponse, err error) {
	var _args MGetCollectionArgs
	_args.Req = Req
	var _result MGetCollectionResult
	if err = p.c.Call(ctx, "MGetCollection", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteCollection(ctx context.Context, Req *collectionModel.DeleteColltRequest) (r *collectionModel.DeleteColltResponse, err error) {
	var _args DeleteCollectionArgs
	_args.Req = Req
	var _result DeleteCollectionResult
	if err = p.c.Call(ctx, "DeleteCollection", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddEntry(ctx context.Context, Req *collectionModel.AddEntryRequest) (r *collectionModel.AddEntryResponse, err error) {
	var _args AddEntryArgs
	_args.Req = Req
	var _result AddEntryResult
	if err = p.c.Call(ctx, "AddEntry", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteEntry(ctx context.Context, Req *collectionModel.DeleteEntryRequest) (r *collectionModel.DeleteEntryResponse, err error) {
	var _args DeleteEntryArgs
	_args.Req = Req
	var _result DeleteEntryResult
	if err = p.c.Call(ctx, "DeleteEntry", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SetName(ctx context.Context, Req *collectionModel.SetNameRequest) (r *collectionModel.SetNameResponse, err error) {
	var _args SetNameArgs
	_args.Req = Req
	var _result SetNameResult
	if err = p.c.Call(ctx, "SetName", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
